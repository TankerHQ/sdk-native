@startuml

set namespaceSeparator ::

class Core {
  +Core(Hash const& trustchainId, PrivateSignatureKey const& trustchainPrivateKey, std::string const& trustchainUrl, std::string const& writablePath)

  +Status status() const

  +void open(tc::awaiter& await, std::string const& userToken)

  +void encrypt(tc::awaiter& await, uint8_t* encryptedData, gsl::span<uint8_t const> clearData)
  +void decrypt(tc::awaiter& await, uint8_t* decryptedData, gsl::span<uint8_t const> encryptedData)

  +void share(tc::awaiter& await, gsl::span<std::string const> resourceId, gsl::span<std::string const> userId)

  +static std::string getResourceId(gsl::span<uint8_t const> encryptedData)
}

note top of Core
  Public API
end note

class Opener {
  -Hash const _trustchainId
  -PrivateSignatureKey const _trustchainPrivateKey

  +Opener(Hash const& trustchainId, PrivateSignatureKey const& trustchainPrivateKey, std::string const& trustchainUrl, std::string const& writablePath)

  +CoreStatus status() const

  +Session::Config open(tc::awaiter& await, std::string const& userToken);

  +boost::signals2::signal<void()> unlockRequired;
}

note top of Opener
  Open a session
end note

class Session {
  -Hash _trustchainId
  -Hash _userId

  +void encrypt(tc::awaiter& await, uint8_t* encryptedData, gsl::span<uint8_t const> clearData)
  +void decrypt(tc::awaiter& await, uint8_t* decryptedData, gsl::span<uint8_t const> encryptedData)

  +void share(tc::awaiter& await, gsl::span<Mac const> resourceId, gsl::span<std::string const> userId)
}

class Trustchain {
  +std::vector<Entry> getUserDevices(Hash const& userId);
  +void addEntry(Entry const& entry);
}
note top of Trustchain
  Store blocks and retrieves verified blocks
end note
class TrustchainStorage {
  +void addEntry(Entry const& entry);
  +Entry getEntry(Hash const& hash);
}
class TrustchainVerifier
class DeviceKeyStore {
  +SignatureKeyPair const& signatureKeyPair() const noexcept;
  +EncryptionKeyPair const& encryptionKeyPair() const noexcept;
}
class ResourceKeyStore {
  +void putKey(Mac const& mac, SymmetricKey const& key);
  +SymmetricKey getKey(Mac const& mac) const;
}

class Client {
  +Client(std::unique_ptr<AConnection> conn, ConnectionHandler connectionHandler = {})

  +void start()
  +void startWithConnectionHandler(ConnectionHandler handler)

  +void pushBlock(tc::awaiter& await, gsl::span<uint8_t const> block)
  +std::string requestAuthChallenge(tc::awaiter& await)
  +void authenticateDevice(tc::awaiter& await, nlohmann::json const& response)
  +std::vector<std::string> getBlocks2(tc::awaiter& await, int index, std::vector<UserId> userId, std::vector<GroupId> groupId)

  +boost::signals2::signal<void()> started
  +boost::signals2::signal<void()> blockAvailable
}
note top of Client
  Send and receive client messages from Trustchain server
  Calls the ConnectionHandler on every reconnection to get authenticated
end note

class Admin {
  -std::string _idToken

  +Admin(std::unique_ptr<AConnection> cx, std::string idToken)

  +void start(tc::awaiter& await)

  +void authenticateCustomer(tc::awaiter& await, std::string const& idToken)
  +Hash createTrustchain(tc::awaiter& await, std::string const& name, SignatureKeyPair const& keyPair, bool isTest = true)
  +void deleteTrustchain(tc::awaiter& await, Hash const& trustchainId)
  +void pushBlock(tc::awaiter& await, gsl::span<uint8_t const> block)

  +boost::signals2::signal<void()> connected
}
note top of Admin
  Send and receive admin messages from Trustchain server
  Authenticate with a jwt token on every reconnection
end note

interface AConnection {
  +using Handler = std::function<void(nlohmann::json const&)>

  +bool isOpen() const
  +void connect()

  +nlohmann::json emit(tc::awaiter& await, std::string const& eventName, nlohmann::json const& data)

  +void on(std::string const& message, Handler handler)

  +boost::signals2::signal<void()> connected
}
class Connection {
  -sio::client _client
  -std::string _trustchainUrl

  +Connection(std::string url)
}
note top of Connection
  Implement connection to the Trustchain with socket.io
end note

class BlockGenerator {
  -Hash _trustchainId
  -PrivateSignatureKey _privateSignatureKey

  +std::vector<uint8_t> addUser(Delegation const& delegation, PublicSignatureKey const& signatureKey, PublicEncryptionKey const& encryptionKey) const
  +std::vector<uint8_t> addDevice(Hash const& author, Delegation const& delegation, PublicSignatureKey const& signatureKey, PublicEncryptionKey const& encryptionKey) const
  +std::vector<uint8_t> keyPublish(Hash const& author, std::vector<uint8_t> symKey, Mac const &mac, Hash const &recipient) const
}
note top of BlockGenerator
  Generate signed blocks to be sent to the Trustchain
end note

class TrustchainPuller {
  +void catchUp(tc::awaiter& await)
}
note top of TrustchainPuller
  Pulls the Trustchain from the server and stores it locally
end note

interface ConnectionHandler {
  +void operator()(tc::awaiter& await, Client& client)
}
class ClientAuthenticator {
  -Hash const _trustchainId
  -Hash const _userId
  -PublicSignatureKey const _publicSignatureKey
  -PrivateSignatureKey const _privateSignatureKey
}
note top of ClientAuthenticator
  Authenticate a client through a challenge/response with the Trustchain server
end note

namespace DB {
  class QueryField << (S,yellow) >> {
    +std::string fieldName;
    +Operator op;
    +Table::Value value;
  }

  class Query << (S,yellow) >> {
    +std::vector<QueryField> selector;
    +std::string sortBy;
    +unsigned long limit;
  }

  interface Transaction {
    +void commit(tc::awaiter& await);
    +void rollback(tc::awaiter& await);
  }

  interface Table {
    +using Value = boost::variant<long, std::vector<uint8_t>>;
    +using Row = std::map<std::string, Value>;

    +void put(tc::awaiter& await, gsl::span<Row const> rows);
    +std::vector<Row> find(tc::awaiter& await, Query const& query);
  }

  interface Database {
    +Table open(tc::awaiter& await, Schema const& schema);

    +Transaction beginTransaction(tc::awaiter& await);
  }
}

Core *-- Opener
Core *-- Session
Opener *-- DB::Database
Session *-- Trustchain
Trustchain *-- TrustchainStorage
Trustchain *-- TrustchainVerifier
Session *-- DeviceKeyStore
Session *-- ResourceKeyStore
Session *-- Client
Session *-- TrustchainPuller
Session *-- BlockGenerator
Client "0..1" o-- ConnectionHandler
Client *-- AConnection
Admin *-- AConnection
TrustchainPuller o-- Client
TrustchainPuller o-- Trustchain

TrustchainStorage o-- DB::Table
DeviceKeyStore o-- DB::Table
ResourceKeyStore o-- DB::Table

ConnectionHandler <|-- ClientAuthenticator
AConnection <|-- Connection

@enduml
