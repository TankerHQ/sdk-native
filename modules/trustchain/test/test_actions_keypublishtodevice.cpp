#include <Tanker/Trustchain/Actions/KeyPublish/ToDevice.hpp>

#include <Tanker/Serialization/Serialization.hpp>

#include <Helpers/Buffers.hpp>

#include <doctest.h>

using namespace Tanker;
using namespace Tanker::Trustchain;
using namespace Tanker::Trustchain::Actions;

TEST_CASE("KeyPublishToDevice tests")
{
  DeviceId const recipient{};
  ResourceId const resourceId{};
  Crypto::EncryptedSymmetricKey const key{};
  KeyPublishToDevice kp(recipient, resourceId, key);

  CHECK(kp.nature() == Nature::KeyPublishToDevice);
}

TEST_CASE("Serialization test vectors")
{
  SUBCASE("it should serialize/deserialize a KeyPublishToDevice")
  {
    // clang-format off
    std::vector<std::uint8_t> const serializedKeyPublishToDevice = {
      // recipient
      0xbd, 0xec, 0xe7, 0xbe, 0x4c, 0xd6, 0xc8, 0x33, 0xec, 0xf9, 0x42, 0xe1,
      0xa9, 0xc4, 0xa7, 0x3e, 0x39, 0xac, 0xdd, 0x6d, 0x99, 0x37, 0xc2, 0x9a,
      0xbf, 0xf8, 0x6c, 0x4f, 0xce, 0x3a, 0x34, 0xcd,
      // resourceId
      0x21, 0x2c, 0x54, 0x3a, 0xae, 0xcf, 0xc6, 0xef, 0x0b, 0x60, 0xae, 0xe6,
      0x11, 0x52, 0xa1, 0x30,
      // key size
      0x48,
      // key
      0x0b, 0x5a, 0xa5, 0x9e, 0xf1, 0x8e, 0x5c, 0xef, 0x61, 0xc4, 0x95, 0x26,
      0x77, 0xe2, 0xb6, 0x96, 0x55, 0x96, 0xbd, 0xbe, 0x7d, 0x8f, 0xfc, 0x8e,
      0x9b, 0xd4, 0xeb, 0xab, 0xd3, 0xaf, 0xa1, 0x36, 0x01, 0x00, 0x8b, 0x86,
      0x08, 0xea, 0xb4, 0xa4, 0x90, 0x67, 0x66, 0xbd, 0x4c, 0xb0, 0x08, 0xe3,
      0x01, 0x00, 0x8b, 0x86, 0x08, 0xea, 0xb4, 0xa4, 0x90, 0x67, 0x66, 0xbd,
      0x4c, 0xb0, 0x08, 0xe3, 0x01, 0x00, 0x8b, 0x86, 0x08, 0xea, 0xb4, 0xa4
    };
    // clang-format on

    auto const kp = Serialization::deserialize<KeyPublishToDevice>(
        serializedKeyPublishToDevice);
    CHECK(Serialization::serialize(kp) == serializedKeyPublishToDevice);
  }

  SUBCASE("it should throw when the serialized key size is incorrect")
  {
    // clang-format off
    std::vector<std::uint8_t> const serializedKeyPublishToDevice = {
      // recipient
      0xbd, 0xec, 0xe7, 0xbe, 0x4c, 0xd6, 0xc8, 0x33, 0xec, 0xf9, 0x42, 0xe1,
      0xa9, 0xc4, 0xa7, 0x3e, 0x39, 0xac, 0xdd, 0x6d, 0x99, 0x37, 0xc2, 0x9a,
      0xbf, 0xf8, 0x6c, 0x4f, 0xce, 0x3a, 0x34, 0xcd,
      // resourceId
      0x21, 0x2c, 0x54, 0x3a, 0xae, 0xcf, 0xc6, 0xef, 0x0b, 0x60, 0xae, 0xe6,
      0x11, 0x52, 0xa1, 0x30,
      // invalid key size
      0x42,
      // key
      0x0b, 0x5a, 0xa5, 0x9e, 0xf1, 0x8e, 0x5c, 0xef, 0x61, 0xc4, 0x95, 0x26,
      0x77, 0xe2, 0xb6, 0x96, 0x55, 0x96, 0xbd, 0xbe, 0x7d, 0x8f, 0xfc, 0x8e,
      0x9b, 0xd4, 0xeb, 0xab, 0xd3, 0xaf, 0xa1, 0x36, 0x01, 0x00, 0x8b, 0x86,
      0x08, 0xea, 0xb4, 0xa4, 0x90, 0x67, 0x66, 0xbd, 0x4c, 0xb0, 0x08, 0xe3,
      0x01, 0x00, 0x8b, 0x86, 0x08, 0xea, 0xb4, 0xa4, 0x90, 0x67, 0x66, 0xbd,
      0x4c, 0xb0, 0x08, 0xe3, 0x01, 0x00, 0x8b, 0x86, 0x08, 0xea, 0xb4, 0xa4
    };
    // clang-format on

    CHECK_THROWS(Serialization::deserialize<KeyPublishToDevice>(
        serializedKeyPublishToDevice));
  }
}
