#include <Tanker/Trustchain/ServerEntry.hpp>

#include <Tanker/Crypto/Crypto.hpp>
#include <Tanker/Serialization/Serialization.hpp>
#include <Tanker/Trustchain/Action.hpp>
#include <Tanker/Trustchain/ComputeHash.hpp>
#include <Tanker/Trustchain/Errors/Errc.hpp>

#include <Helpers/Buffers.hpp>
#include <Helpers/Errors.hpp>

#include <doctest.h>
#include <gsl-lite.hpp>

using namespace Tanker;
using namespace Tanker::Trustchain;

TEST_CASE("Serialization test vectors")
{
  SUBCASE("it should deserialize a ServerEntry")
  {
    // clang-format off
    std::vector<std::uint8_t> const serializedServerEntry = {
      // varint version
      0x01,
      // varint index
      0x02,
      // trustchain id
      0x74, 0x72, 0x75, 0x73, 0x74, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x20, 0x69,
      0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // varint nature
      0x01,
      // varint payload size
      0x20,
      // TrustchainCreation: public signature key
      0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x61,
      0x74, 0x75, 0x72, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // author
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // signature
      0x73, 0x69, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
    };

    std::vector<std::uint8_t> const serializedPayload = {
      0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x61,
      0x74, 0x75, 0x72, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    // clang-format on

    auto const trustchainId = make<TrustchainId>("trustchain id");
    auto const nature = Actions::Nature::TrustchainCreation;
    Crypto::Hash const author{};
    auto const signature = make<Crypto::Signature>("sig");

    ServerEntry const serverEntry{
        trustchainId,
        2,
        author,
        Action::deserialize(nature, serializedPayload),
        computeHash(nature, author, serializedPayload),
        signature};

    CHECK(Serialization::deserialize<ServerEntry>(serializedServerEntry) ==
          serverEntry);
  }

  SUBCASE("it should throw when block version is unsupported")
  {
    std::vector<std::uint8_t> const serializedServerEntry = {
        // varint version
        0x0f,
    };

    TANKER_CHECK_THROWS_WITH_CODE(
        Serialization::deserialize<ServerEntry>(serializedServerEntry),
        Errc::InvalidBlockVersion);
  }
}
